/*
	Copyright 2021, 2023-2024 Gabriel Bj√∏rnager Jen-
	sen.

	This file is part of benoit.

	benoit is free software: you can redistribute it
	and/or modify it under the terms of the GNU Af-
	fero General Public License as published by the
	Free Software Foundation, either version 3 of
	the License, or (at your option) any later ver-
	sion.

	benoit is distributed in the hope that it will
	be useful, but WITHOUT ANY WARRANTY; without
	even the implied warranty of MERCHANTABILITY or
	FITNESS FOR A PARTICULAR PURPOSE. See the GNU
	Affero General Public License for more details.

	You should have received a copy of the GNU Af-
	fero General Public License along with benoit.
	If not, see <https://www.gnu.org/licenses/>.
*/

mod dump_image;
mod generate;
mod plot;

use crate::error::Error;
use crate::render::{ImageElement, RawElement, RenderConfig};

use std::mem::size_of;
use std::ptr::from_ref as ptr_from_ref;
use std::slice::from_raw_parts as slice_from_raw_parts;

/// Container for raw render data and image buffer.
#[derive(Clone)]
pub struct Render {
	size: (u32, u32),

	raw_data:   Option<Box<[RawElement]>>,
	image_data: Option<Box<[ImageElement]>>, // RGBA8

	last_config: Option<RenderConfig>,
}

impl Render {
	/// Creates a new render with the given dimensions.
	/// The internal buffers must be allocated using [`Render::generate`] and [`Render::plot`].
	///
	/// # Panics
	///
	/// Panics if the given size yields a product of zero.
	pub const fn new(width: u32, height: u32) -> Result<Self, Error> {
		let data_length = height as usize * width as usize;
		if data_length == 0x0 {
			return Err(Error::ZeroLengthRender);
		}

		Ok(Self {
			size: (width, height),

			last_config: None,

			raw_data:   None,
			image_data: None,
		})
	}

	/// Resizes the render to the dimensions specified by `size`.
	/// Both buffers are destroyed in the process and must be reallocated using [`Render::generate`] and [`Render::plot`].
	///
	/// If, however, the size remains unchanged, the structure also remains unchanged (including buffers).
	///
	/// # Panics
	///
	/// Panics if the given size yields a product of zero.
	pub fn resize(&mut self, size: (u32, u32)) -> Result<(), Error> {
		if size == self.size { return Ok(()) };

		let len = size.1 as usize * size.0 as usize;
		if len == 0x0 {
			return Err(Error::ZeroLengthRender);
		}

		// Remember that the buffers are lazily allocated.
		self.raw_data   = None;
		self.image_data = None;

		Ok(())
	}

	/// Returns the dimensions of the render.
	#[inline(always)]
	#[must_use]
	pub const fn size(&self) -> (u32, u32) { self.size }

	/// Borrows the raw render data as generated by [`Render::generate`].
	///
	/// If no render has been generated, [`None`] is returned instead.
	#[inline(always)]
	#[must_use]
	pub fn raw_data(&self) -> Option<&[RawElement]> { self.raw_data.as_deref() }

	/// Borrows the image data as plotted by [`Render::plot`].
	///
	/// If no image has been plotted, [`None`] is returned instead.
	#[inline(always)]
	#[must_use]
	pub fn image_data(&self) -> Option<&[ImageElement]> { self.image_data.as_deref() }

	/// Converts the image data to a slice of raw [`u8`] elements.
	///
	/// This is particularly useful when needing to encode the image using format-agnostic encoders.
	///
	/// If no image has been plotted (as by [`Render::plot`]), [`None`] is returned instead.
	#[must_use]
	pub fn image_as_bytes(&self) -> Option<&[u8]> {
		let data = ptr_from_ref::<[ImageElement]>(self.image_data.as_ref()?);

		let length = self.size.1 as usize * self.size.0 as usize * size_of::<ImageElement>();
		let data   = unsafe { slice_from_raw_parts(data.cast::<u8>(), length) };

		Some(data)
	}

	/// Borrows the last render configuration used.
	///
	/// If no image has been plotted (as by [`Render::plot`]), [`None`] is returned instead.
	#[inline(always)]
	#[must_use]
	pub const fn last_config(&self) -> Option<&RenderConfig> { self.last_config.as_ref() }

	/// Allocates an internal buffer.
	///
	/// This function is generic and can in practice be used for any buffer.
	///
	/// The buffer's length is set according to the dimensions of `self`.
	#[must_use]
	fn allocate_buffer<T: Clone + Default>(&self) -> Box<[T]> {
		let len = self.size.1 as usize * self.size.0 as usize;
		vec![Default::default(); len].into_boxed_slice()
	}
}
